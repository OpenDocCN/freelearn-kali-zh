## 第七章。注入和溢出测试

在当今这个时代，所有网站都会对用户提供动态响应，这些响应受到一些外部数据库的影响或从 HTML 本身外部的过程推断出来。在客户端，这通常被隔离并限制在浏览器的 DOM 空间中，但在服务器上，这些交织在一起的过程的种类和范围变得异常难以管理。典型企业的所有防御都被调整为允许应用程序绑定流量进入 Web 层，反过来，Web 层被信任访问应用程序和数据库层，黑客已经学会了将 Web 层变成他们的替身。Web 层无意中成为内部威胁，随之而来的是所有特权访问和信任关系。

注入是一种强大且常见的客户端-服务器连接的妥协形式，既可以用来暴露意外信息，也可以影响应用程序本身的性能。XSS 攻击侧重于注入脚本以诱使客户端执行攻击者的命令，而其他注入类型则直接针对后端数据。当我们测试或攻击 Web 应用程序时，妥协用户主机是有用的，但一系列服务器端注入可以诱使 Web 应用程序直接执行黑客的命令。这些注入攻击在应用中各不相同，但利用了 Web 应用程序验证用户输入和掩盖错误处理的弱点。攻击者的动机有很多，但除了窃取应用程序背后的数据或知识产权之外，还有更具破坏性的结果——破坏或损坏数据，破坏应用程序的可用性，破坏其在用户和公司中的信任地位。

注入最令人担忧的一点是它们很容易实施，而且很多网站都容易受到攻击。快速查看 Google Hacking DB（GHDB）或 Shodan.io 可以很容易地暴露出数百万缺乏保护的服务器。

我们当然应该对这些开源情报（OSINT）库进行粗略查看，因为黑帽骇客肯定在使用它们。使用 Burp Suite、Zed Access Proxy（ZAP）、Arachni 和其他工具进行重点扫描可以帮助我们发现特定目标中更广泛的潜在问题，以及一些与门户网站本身的智能互动。结构化查询语言（SQL）、可扩展标记语言（XML）路径语言（XPath）、轻量级目录访问协议（LDAP）、命令/可执行文件和超文本传输协议（HTTP）注入是最常见的威胁，但在影响和位置上有所不同。

在这一章中，我们将学习并实施注入和输入操纵攻击的主要类别，并学习如何使用几种工具来识别漏洞并利用它们的弱点。

本章将帮助我们：

+   发现并针对各种注入形式（盲目、经典、复合）进行测试，包括针对 SQL、Oracle 和 LDAP 等各种数据库

+   了解执行代码注入以导致堆栈、缓冲区和堆溢出的需要

+   学会进行 HTTP 动词篡改和参数污染

+   学会如何从 recon-ng、BBQSQL、SQLMap、SQLninja 等工具列表中选择并使用正确的工具

## 在测试中注入一些乐趣

* * *

注入攻击很多，但因为它们都插入代码，而且知道这些代码将被传输到应用程序或数据库层进行执行，所以它们的影响使得注入在 OWASP 十大中排名第一。我们将在这里介绍一些主要的攻击方式，但要知道扫描和测试方法非常相似，我们将利用自动化来探测每个门户的弱点迹象，并传递基于最佳实践的字符串来测试潜在的缺陷。在我们深入了解注入的各种类型之前，了解 OWASP 是如何对它们进行分类的会有所帮助。以下截图来自他们最新的发布候选版的**OWASP 2017 十大**列表([`github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf`](https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf))：

![](img/B03918_07_01.png)

OWASP 的注入攻击特征。

OWASP 对这些攻击的关注点很多，但黑客的使用便利性和潜在影响使它们成为应用程序开发人员的严重关注点。Web 技术在很大程度上依赖于动态内容，这使得黑客将其视为注入的目标。以下表格可以帮助我们了解每种攻击的基本范围、相对难度以及它们通常被发现的弱点：

| **注入类型** | **检测难度** | **利用难度** | **潜在影响** | **最终目标/受影响组件** |
| --- | --- | --- | --- | --- |
| **SQL 注入** | 困难 - 盲注易 - 经典 | 中等 | 非常严重 | 数据库枚举 SQL 支持的框架 Oracle 应用程序 |
| **XML（XPath）注入** | 中等 | 简单 | 严重 | XML 存储的数据枚举、破坏、销毁 |
| **LDAP 注入** | 非常简单 | 简单 | 中等（各不相同） | 凭证，通常用于升级或生成新账户 |
| **命令注入** | 困难 | 中等 | 非常严重 | 应用程序层插入命令以运行恶意代码，用于破坏或横向移动 |
| **缓冲区溢出** | 中等 | 中等 | 非常严重 | 应用程序层重新指向指令以执行恶意代码，用于破坏或横向移动 |
| **HTTP 注入** | 简单 | 非常简单 | 低 | Web 或应用程序层强制在 Web 服务器或应用程序内执行功能 |

## SQL 有用吗？

* * *

就注入而言，**SQL 注入**（SQLI）是最受欢迎的。尽管 SQL 数据库技术之间存在差异，但大多数都遵循**美国国家标准学会**（**ANSI**）定义的共同基础语法、词汇和组织，这使得学习和适应新技术变得简单高效。它是关系数据库中的工作马，负责从相邻的应用程序或接口存储、操作和查询数据库。有很多免费资源值得深入了解 SQL，**万维网联盟**的网站([`www.w3schools.com/sql/`](https://www.w3schools.com/sql/))是一个很好的起点，我们不会深入讨论底层语言。

统计数据显示，超过 98%的 Web 应用程序都由包含用户所需信息的数据库支持。其中，SQL 变体是最受欢迎的。这些相同的特点使得黑客很容易使用常见的查询和技巧来检测和利用这些数据库。

不过，不要被这些统计数据和潜在影响所迷惑：SQLI 攻击每年都在激增，尽管它们受到了关注，而且可以采取基本预防措施来消除或大大减少对应用程序的潜在影响。正如我们将在这里看到的，揭示和利用 SQL 注入漏洞是一个相对容易的任务。

### 数据库崩溃课程

关系数据库提供了一个类似表格的框架，用于存储数据。 SQL 是我们读取和写入这些表的语法，网站可以允许他们的用户通过构建查询并随后呈现结果来呈现有用的数据。会出什么问题呢？

嗯，许多数据库是由没有特定数据库技术背景的系统管理员或工程师实例化的。很可能你的技术恐惧症亲戚甚至在自己的个人电脑上安装了数据库作为应用程序的基础组件。同样有可能的是，将数据库嵌入到更大的应用程序中的人并没有深入研究数据库的详细硬化。简单的事情，比如默认管理员帐户、端口等在嵌入到父应用程序之前并不总是被清理干净。这些问题在没有专注于数据库的人员的组织中的 Web 应用程序数据库中也会出现。

Web 应用程序在征求用户查询和将其传递到数据库的方式上有所不同。许多使用**PHP 超文本预处理器**（**PHP**）进行动态内容的网站通过**统一请求定位器**（**URL**）字符串传递查询，因此非常容易修改以符合我们自己的目的，同时避免有意义的验证。其他网站通过限制用户通过预先制作的下拉列表、单选按钮和复选框构建搜索来强制执行和清理底层 SQL 查询。这些限制性的查询构建方法更难以利用，并且在可能的情况下建议用于安全的应用程序开发。

以下屏幕截图显示了这种情况发生的高层视图。

![](img/B03918_07_02.png)

SQL 注入攻击的解剖

### SQLI 的类型

考虑到 SQL 的多样性和实现它的方式有很多种，很有道理会有一些不同的实现 SQLI 的方式。与 XSS 一样，我们可以从几个方面来看待这个问题，但 SQLI 可能会有很大的变化，因此可以用不同的方式来描述。与 XSS 不同，我们可以通过观察一些*提示*或特征来区分 SQLI：

+   SQLI 的交付方式（通过表单、下拉列表、cookie 操作、URL 修改等）

+   我们首先提交的输入类型（字符串与值）

+   我们如何接收数据（也称为数据提取通道）

+   响应的构建方式（返回错误或隐藏任何故障）

+   影响应用程序或数据库产生结果所需的查询数量

我们不会详尽地涵盖所有这些类别，但我们将讨论常用的类型以及它们如何适用于上述类别。此外，我将使用我们信赖的 OWASP **破损 Web 应用程序**（**BWA**）**虚拟机**（**VM**）来展示一些示例，并且我们将看到我们如何依次处理每个类别，包括实际的注入技术以及可以自动化使用的工具。

#### In-band 或经典 SQLI

**In-band SQLI**是 SQLI 的最简单和最常见的模式，通常称为**经典 SQLI**类型。 In-band 更好地描述了攻击的进行方式。 In-band SQLI 涉及通过相同的通道发起攻击（恶意 SQL 查询）和接收响应（该查询的结果）。黑客可以以几种方式使用这些攻击。

+   **基于错误的 SQLI**：黑客可以使用意图使响应出错的字符串来探测应用程序，这些响应可以揭示网站的结构和策略，但有助于绘制和枚举应用程序正在使用的数据库。下面的 Mutillidae 示例显示了一个语句，当注入请求时，将引发详细错误，实际上可以告诉我们底层的信息：

```
username=''' AND (SELECT 6803 FROM(SELECT COUNT(*),CONCAT(0x71627a6271,(SELECT (ELT(6803=6803,1))),0x716a7a7a71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- sFFK&password=''&login-php-submit-button=Login 
```

+   **基于联合的 SQLI**：在更精确的方法中，黑客（我们）可能已经勘察了数据库，现在将试图将单独的语句（使用*union*语句）合并为一个请求，以从应用程序中引出意想不到的结果。通过这样做，他们可以利用一个探测性查询和应用程序期望的内容结合起来，在返回结果时实际上泄露信息！

#### 盲注入

**盲注入**就像是数据库版本的童年游戏*热或冷*。如果你从未玩过，藏玩具的孩子通过说*热*来提供给搜索者提示，随着搜索者的接近程度，热度的程度也会有所不同，当他们离隐藏的目标越来越远时则说*冷*。盲注入也是如此：当数据库不直接告诉你，应用程序开发人员又隐藏错误细节时，有时你可以通过推断答案并提出正确的*真或假*问题来获取所有信息。当然，通过经典的 SQLI 模式之一直接获取数据会更容易，但是通过查询作为真/假探测，黑客可以系统地枚举数据库，甚至不需要返回任何数据。也就是说，盲注入有两种主要类型。

+   **基于内容的盲注入**：在这种类型的 SQLI 中，黑客试图使用查询来推断数据库中的数据类型、条目或结构的存在，通过观察应用程序是否返回错误，或者基于真或假条件返回不同的错误。下面是 Mutillidae 应用程序中的一个 MySQL 示例：

```
username=-1419' OR 7078=7078#&password=''&login-php-submit-button=Login 
```

+   **基于时间的盲注入**：盲注入的另一种形式帮助克服了 Web 层的任何错误筛选，通过操纵查询中的基于时间的命令。当我们将基于时间的命令与布尔（也称为条件）查询结合在一起，并观察到在指定时间后出现错误时，这就成为我们的真/假试金石测试。SQL 有一些等待和休眠语句，有时会被接受；当与数据库可能不想直接返回答案的查询结合时，延迟可能就是我们需要枚举内容的所有答案。以下是一个示例：

```
username=''' AND 9120=BENCHMARK(25000000,MD5(0x6b4e4344))-- yHeA&password=''&login-php-submit-button=Login 
```

无论你如何处理盲注入，它都是相当费力的，不是你在现实世界中想要手动完成的事情；使用真/假测试在表中找到每个字母并逐个浏览整个字母表是高性能计算的工作，而不是人类的工作。因此，建议您只在没有其他选择时尝试盲注入。诸如 SQLMap 和 SQLninja 之类的工具可以帮助自动化这一过程，但正如我们将很快看到的，盲注入扫描可能是一个漫长而冗长的过程。

#### 堆叠或复合 SQLI

一旦你了解了经典和盲注入的方法，就不难理解如何制作复合语句，并将多个请求堆叠在一起，不仅可以映射我们的目标数据库，还可以操纵、破坏或销毁存储的数据，并最终在数据库上运行代码。例如，你可以将基于联合的 SQLI 的数据提取与紧随其后的命令配对，从源表中删除数据。**Netsparker**（[`www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/`](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/)）和**PenTestMonkey**（[`pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet`](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)）都提供了一份很好地介绍了堆叠 SQLI 可以在多种数据库类型上用于正面（或负面）的作用的备忘单。在这里造成伤害的潜力是巨大的，因此最好使用标准的 Kali 提供的工具（或其他**动态应用安全测试**或**DAST**套件）进行扫描和测试，而不是自己设计漏洞利用。

### SQLI 工具学校

现在我们知道如何判断每种 SQLI 注入类型对目标的影响以及它如何帮助黑客，我们需要一些方法来实际检测和利用这些漏洞。正如我们所看到的，注入攻击有各种各样的实施和影响，正如您所期望的那样，有大量工具可以满足渗透测试人员和黑客的需求。然而，我的目标是为您提供一套可以在各个方面提供覆盖并为您节省时间的工具基础，同时在需要时学习和专门化。在本节中，我们将看到如何使用 SQLMap、BBQSQL、SQLNinja 和一些老式的浏览器魔术来识别和利用 SQLI 漏洞。

#### 通过浏览器进行老式 SQLI

开玩笑的时候到此为止，有经验的黑客会编写脚本来爬取应用程序的所有潜在页面，然后访问每个页面进行调试，以了解是否可能进行 SQLI。扫描工具很有趣，但没有什么比仅使用浏览器来获取访问权限、提升权限或渲染敏感数据更能向客户展示攻击的严重性。举个例子，如果我们想试图诱使页面透露其查询语法，我们可能会强制出现错误，如下截图所示，数据库试图告诉我们如何纠正它：

![](img/B03918_07_03.png)

强制 SQL 错误

当我们点击**`登录`**按钮时，我们有帮助的数据库泄露了秘密，我们意识到我们要攻击的查询到底是什么，如下截图所示：

![](img/B03918_07_04.png)

SQL 错误真是太有帮助了！

仔细看，我们要处理的查询只是在一个名为`accounts`的表中寻找一个名为`username`的字段：

```
SELECT username FROM accounts WHERE username=''' 
```

通过查看这个简单的查询，并应用从 SQLI 作弊表或实际学术知识中获得的一些 SQL 知识，显然这个查询成功地使我们脱离了查询，下一步我们应该尝试欺骗一个有效的用户名，并尝试跳过密码。我们可以通过输入一个新的字符串来实现这一点，其中`' or 1=1 --`将使用逻辑操作来确保用户名存在，双破折号和尾随空格告诉 SQL 跳过接下来的字段；在这种情况下，它方便地跳过了我们讨厌的密码字段。当我们将该字符串输入到用户名字段时，新的查询看起来是这样的：

```
SELECT username FROM accounts WHERE username='' or 1=1 -- ' 
```

这点 SQL 知识为我们赢得了一次相当关键的胜利：我们现在以管理员身份登录，如下截图所示：

![](img/B03918_07_05.png)

SQLI 如此令人畏惧的原因。

我想我们都可以同意这相当方便——有意漏洞的 Mutillidae 应用程序很容易攻破。管理员被还原，因为大多数未经加固的数据库都是如此，管理员用户是用户数据库中的第一个条目。然而，现实世界中的 SQLI 可能就是这么简单，只要黑客具有深入的 SQL 知识并愿意尝试和解释 Web 应用程序返回的错误。在这方面非常有帮助的工具是 Firebug Firefox 浏览器插件（[`addons.mozilla.org/en-US/firefox/addon/firebug/`](https://addons.mozilla.org/en-US/firefox/addon/firebug/)），它可以帮助您揭示密码字段，并在通常被隐藏的字段中注入 SQL 查询。如果您有很多其他任务要处理，无法忍受亲自操作的时间，还有一些有用的工具可以迭代这些查询并为我们解释响应。

#### 使用 SQLMap 加强

让我们看看我们已经熟悉的工具 Burp Suite 如何被用于向 Kali 最古老的工具之一 SQLI，**SQLMap**，以帮助检查各种 SQLI。警告一下-虽然 Burp 的速度和多功能性都很快，但 SQLMap 需要很长时间来完成其许多测试。本章的测试运行在一个性能强大的虚拟机上花了超过 10 个小时（4 核，8GB 的 RAM），但是等待是值得的。让我们看看这个过程是如何工作的。

首先，我们需要拂去灰尘，启动 Burp Suite，将其设置为我们的代理，并允许其拦截我们的请求。做到这一点后，我们可以浏览到我们一直在攻击的相同登录页面，输入一些访客凭据，并在我们的**`Proxy`**选项卡和**`Intercept`**子选项卡中捕获请求（如下图所示）。请注意，这在最后一行捕捉到了我们的虚假凭据，以及 SQLMap 可能需要执行其工作的其他重要格式和语法细节：

![](img/B03918_07_06.png)

捕获我们的请求。

方便的是，Burp Suite 允许我们直接将其保存到文件供 SQLMap 使用（如下图所示）：

![](img/B03918_07_07.png)

保存我们的请求供 SQLMap 使用。

使用您喜欢的编辑器（在我的情况下是**nano**），您可以将凭据字段更改为两个单引号，如下图所示：

![](img/B03918_07_08.png)

编辑请求后再传递给 SQLMap。

现在，您可以执行`SQLMap`并将您的响应文件传递给它，以及设置您感兴趣的任何其他选项，使用`SQLMap`命令：

```
SQLMap -r mutillidae_SQLMap.req --threads=10 â��b â��-time-sec 10 
```

现在我们应该看到`SQLMap`正在进行测试，如下图所示，测试各种漏洞并从 SQL 角度为我们勾画我们的目标。

![](img/B03918_07_09.png)

SQLMap 测试进行中。

我们需要回答一些问题，但在这些练习场景中，通常可以对所有问题回答是。经过长时间而紧张的扫描后，`SQLMap`将以潜在易受应用程序影响的注入摘要回应，并对数据库和 Web 应用程序本身进行表征，如下图所示：

![](img/B03918_07_10.png)

SQLMap 的输出显示了 SQLI 类型和服务器信息。

### 注意

您可能会认出我之前提供的注入点，我将它们作为本章前面一些类型的示例。这些可以直接通过 Burp 或 ZAP 插入到请求中，并立即验证。

#### 使用 BBQSQL 制作一些菜单驱动的 SQLI

SQLMap 是一个用于详尽发现的好工具，但有时您渴望一种菜单驱动的方法来实际利用特定的东西，特别是在盲 SQLI 周围。如果您不是 SQL 专家，但知道您需要从某个主机定制一个特定的利用程序，您可以使用**BBQSQL**（[`github.com/Neohapsis/bbqsql`](https://github.com/Neohapsis/bbqsql)）来定制一个盲 SQLI 利用程序，这是由 Neohapsis（现在是思科的一部分）开发的工具。如果您是**社会工程工具包**（**SET**）的忠实粉丝，并且想要快速利用盲 SQLI，那么 BBQSQL 就是为您量身定制的！让我们快速看一下如何配置它并将其用于您自己的目的。

要启动 BBQSQL，我们不需要捕获请求进行有效分析，但复制一个测试请求以帮助构建攻击是有帮助的。我们可以通过 GUI 快捷方式启动它，或者在 CLI 中使用`bbqsql`启动。起始页面（如下图所示）对 SET 用户来说非常熟悉，这有助于我们更轻松地开始：

![](img/B03918_07_11.png)

BBQSQL 启动菜单（用蓝色标出）。

逐个浏览每个菜单（见下图），大多数基本参数都在 HTTP 选项中。这是我们可以输入 URL、任何输入字段以及自定义代理和任何代理信息的地方。

![](img/B03918_07_12.png)

BBQSQL HTTP 菜单。

BBQSQL 特定参数是 BBQSQL 引擎的核心。以下是重要或最基本的选项：

+   **技术**：定义这是一个真/假测试（`binary_search`）还是基于频率/时间的测试，计算出现次数（`frequency_search`）。

+   **比较属性**：这是我们告诉 BBQSQL 要寻找的内容，并且它将用于区分真假的内容。大小、文本字符串、值和许多其他类型的比较都是可用的。

+   **并发性**：BBQSQL 的速度是其支持的并发性的直接结果，这使其能够以比其他方法更快的速度发现数据库内容。

+   **Hooks 文件**：您可以使用 hooks 来装饰您的攻击，这是其他工具中没有的一项改变游戏规则的 Python 定义功能，因为它们允许进行各种可能需要在发送注入请求过程中发生的操作，比如加密、循环、编码或掩码。

+   **查询**：虽然其他 SQLI 工具针对特定数据库平台进行处理，但 BBQSQL 选择伪代码，允许您创建可跨 SQL 类型工作的利用程序，甚至是 Oracle。这些查询可以在 URL、cookies 或数据本身中使用（请参见以下屏幕截图）。

![](img/B03918_07_13.png)

BBQSQL 选项菜单。

我强烈建议不仅针对 Mutillidae 应用程序进行练习，还要针对 OWASP BWA VM 上提供的其他应用程序进行练习，比如**Damn Vulnerable Web Application**（**DVWA**），或者从[`www.vulnhub.com`](http://www.vulnhub.com)上新发布的应用程序。

另一个值得关注的工具是**SQLninja**（[`sqlninja.sourceforge.net/index.html`](http://sqlninja.sourceforge.net/index.html)），它适用于基于 Microsoft SQL 的项目，是一个基于 Perl 的工具，可在 Kali Linux 中使用。 SQLninja 在利用和注入基于检测结果的其他工具的特定数据库子集方面做得非常出色。由于其范围较窄，我们在这里没有涵盖该工具，但对于那些目标数据库是基于 Microsoft 的情况，它可能非常有价值！

### SQLI 与 Oracle 高端化

如果 SQL 注入是最常见且易于实施的，那么 Oracle 注入就是它们富有和独特的表亲。Oracle 数据库需要付费许可和对其更常见和广泛的 SQL 表亲的高级知识。这使它们更适用于更昂贵的 Web 应用解决方案，因此它们在更大的企业或愿意为更大的内在可扩展性和企业级支持付费的企业中最常遇到。

可以说 Oracle 注入攻击是值得了解或在您的工具箱中拥有的。为什么呢？扫描结果返回识别 Oracle 作为底层 DB 框架的结果，实际上也在宣传其内容的更高价值。建立和维护它们的费用通常是合理的，考虑到它们所持有的价值：Oracle 数据库被信任保存一些非常敏感和有价值的信息。因此，虽然我们更常见地看到 SQL 注入，但学习 Oracle 的方法并确保我们在机会出现时做好准备只需要很少的努力。请放心，我们的黑帽对手也在寻找这些进入应用程序的路径，所以我们最好先于他们找到！

### 注意

BBQSQL、SQLMap 和其他工具都提供了 Oracle 模块或扩展，以确保它们也受到覆盖。在 Oracle 中也可以使用在黑客 MySQL、PostgreSQL 和其他数据库中使用的大部分 ANSI 指令集，因此尽管结构上的差异值得注意，但这些工具应该能够提供帮助。

## X 因子 - XML 和 XPath 注入

* * *

一些应用程序开发人员正在摒弃 SQL，转而使用基于 XML 编写的新的、开放标准的数据结构。为什么会有人选择这样做呢？使用 SQL 构建的关系数据库无疑是利用了非常稳定、成熟的技术，但有时具有多个关系索引的数据在呈现和存储为 XML 时更加紧凑。这需要在数据库层面的性能方面进行权衡。关系数据库区分不同的变量类型，这意味着它们可以根据字符串、整数、布尔值或其他类型进行优化处理。XML 将所有内容都视为文本字符串，因此应用层需要对存储的数据进行检查，并使用更复杂的逻辑和处理开销进行操作。没有 100%正确的答案-这些因素将被权衡，以确定每个应用程序所需的混合方式。

在与数据交互时，可以使用 XML 本身，也可以使用**XML Path Language**（**XPath**）来向存储的数据传递类似 SQL 的命令、请求和操作。XML 实际上并不是一种数据存储技术，而更多地是一种传输/交付标准。如果我们正在针对的 Web 应用程序将大部分时间用于使用 SQL 来提取或操作数据，然后必须将其转换并创建 XML 表示，那么只使用 XML 可能会大有帮助。好消息是我们也有很多可用于 XML 的工具。Burp Suite 和 OWASP ZAP 将检测一些 XML 注入漏洞，就像 SQLI 一样，浏览器或 XML 查看器可以在这方面提供很大的帮助。

### XML 注入

XML 注入通常是将数据插入到 XML 元素中，无论是在其**节点属性**，**节点值**还是**CDATA**字段中。在下面的片段中，我们看到了一个简单的条目，用于我可能正在购物的东西，但希望能以更便宜的价格得到（这是一个模拟的场景，我总是以公平的价格购买饮料）：

```
<catalog>
   <item id="607">
       <brand>Russian River</brand>
       <beer>Pliney the Elder, 12 oz.</beer>
       <price>8.99</price>
   </item>
</catalog>
```

现在，如果我对支付不感兴奋，或者希望免费获得它，我可以通过 XML 传递有效负载，稍微改变游戏规则。这是我可能插入到服务器的 XML 文件中的有效负载：

```
3.99</price></item><item id="608"><brand> Russian River</brand><beer>Pliney the Younger, 16 oz.</beer><price>3.99
```

这给我带来了如下的代码：

```
<catalog>
   <item id="607">
       <brand>Russian River</brand>
       <beer>Pliney the Elder, 12 oz.</beer>
       <price>3.99</price>
   </item>
   <item id="608">
       <brand> Russian River</brand>
       <beer>Pliney the Younger, 16 oz.</beer>
       <price>3.99</price>
   </item>
</catalog>
```

### 注意

实际上，通过普通的 XML 获得对生产服务器的这种访问几乎是不可能的。这也意味着 Kali 托管的工具中没有多少 XML 注入，但是这奠定了理解后端服务器使用 XPath 操纵 XML 的更真实可能性的基础。

### XPath 注入

**XPath**是 XML 人员嫉妒 SQL 并发明自己的查询语言时发生的事情。好消息（对于黑客来说）是 XPath 具有全有或全无的含义，如果你获得了一些访问权限，你就能获得全部！抱歉，XML 人，当你试图让一个标准做太多事情时，就会发生这种情况。与 SQL 不同，XPath 缺乏细粒度的访问控制，因此没有特权层级可供导航，如果你可以枚举一个字符，你就知道你能够捕获所有字符。希望我们的目标开发人员能理解这些权衡，并通过其他方式进行保护，以防止访问或验证所有交易。

XPath 注入一旦掌握了 SQLI 的基础，就变得非常简单。我们正在寻找暴露逻辑或更好地说，给予我们完全访问权限的转义字符。首先，让我们进入**Broken Web App**（**BWAPP**）的**`XML/XPath Injection (Login Form)`**漏洞页面，并打开我们的门户，我将在下面的截图中展示如何找到它。这个虚拟机包含在我们一直在使用的 OWASP BWA 中。你可能已经注意到了，但显而易见的是，OWASP BWA 虚拟机是除了 Kali 本身之外最重要的培训工具，而且是免费的！

![](img/B03918_07_14.png)

查找 Broken Web App XPath 注入页面

如果我们再次使用我们的单引号字符，观察任何错误，我们可以测试潜在的 XPath 注入的输入验证不足（如下截图所示）：

![](img/B03918_07_15.png)

指示可能存在 XPath 注入的错误

与我们在 SQL 中看到的`' or 1=1 -â��`字符串不同，我们将在**`Login`**和**`Password`**字段中使用 XPath 变体的`' or '1'='1`，告诉 XPath 查询*请查找这个转义字符，因为 1 等于 1，所以我们是合法的！*我们希望进行验证以清理这些输入，但令人费解的是，有多少服务器将使用这个字符串返回登录成功，如下截图所示：

![](img/B03918_07_16.png)

使用 XPath 注入登录

使用浏览器理解这个过程很棒，但是当您让工具帮助时，您还可以做更多。**Recon-ng**是一个出色的 CLI 工具，提供了类似于 Metasploit 或 Websploit 的菜单结构，与`xpath_bruter`模块（由 Tim Tomes 精心管理）一起，帮助自动传递**Blind XPath 注入**有效负载以列举主机。我们还将与 Burp Suite 合作，以便我们可以收集我们需要的输入。因此，启用代理，准备好支配 BWAPP！让我们首先看看`recon-ng`从我们这里需要什么，如下截图所示：

![](img/B03918_07_17.png)

Recon-ng 的 XPath_Bruter 模块

假设我们是 OSINT 忍者，也许我们进行了一些社会工程学，发现 Thor 是一个用户，他的密码相当天真，是 Asgard。我们可以使用这一组凭据来设置我们的盲目 XPath 注入。从前面的`show options`命令的输出中，您可以看到我们需要一些东西来开始。以下截图突出显示了我们大部分需要的字段。

![](img/B03918_07_18.png)

我们的 Burp Suite 捕获以供 Recon-NG 使用

首先，我们将获取**BASE_URL**（红色）。然后您需要参数字段，这是我们将要暴力破解以列举数据的 URL 字符串的一部分（绿色）。我们将使用登录参数在 true 和 false 之间切换。假设您现在能拦截所有请求，您应该看到该门户网站使用 HTTP GET 消息提交查询（如蓝色所示），这意味着查询嵌入在发送到服务器的 URL 中。最后，这个特定的门户网站使用 cookies，所以我们可以粘贴整个字符串（紫色）。

Recon-ng 的`XPath-Bruter`模块将要知道所有这些，它还将要知道我们如何区分真假（`string`变量）。因此，如果我输入我知道是真实凭据（我们的真实条件），我会收到 Thor 的秘密消息，所以我可以使用单词`Earth`作为我的字符串。如果我使用已知的假条件进行布尔`and`条件（在撰写本书时，1 肯定不等于 2），那个字符串将不会出现。

所以让我们输入这些变量，将 Burp 和我们的代理配置排除在外，执行我们的暴力攻击！我们将在几分钟内看到的是下面截图中列举的：包含所有用户帐户的`heroes.xml`文件的整个内容：

![](img/B03918_07_19.png)

从 recon-ng 的 xpath_bruter 模块列举的 XML

您会发现其他注入工具非常遵循类似的方法。检测技术集中在试错过程中寻找可以帮助暴露缺陷的字符串，而利用（在道德黑客中）通常专注于枚举。黑客可能使用其中一些工具来实际损坏、操纵或破坏数据，但他们通常使用自定义的 Python 或 Ruby 脚本来执行这些恶意攻击，或者利用暗网上提供的框架。用于更高级基于 CLI 的注入测试的更好的工具之一是 Wapiti（[`wapiti.sourceforge.net/`](http://wapiti.sourceforge.net/)），因为它可以帮助进行 SQL 和 XPath 注入，并支持大量的命令行开关、选项和用例。

## 凭证 Jedi 心灵技巧

* * *

数据库管理员、分析专家和数据科学家因帮助构建、管理和提供各种数据库类型的数据而获得高额报酬，这是理所当然的。但即使一个应用程序不使用这项技术，或者一个企业不直接投资这些数据库类型，我敢打赌他们都安装了一个数据库，这个数据库对他们的内部运作来说可能更重要--凭证数据库。每当客户使用**Microsoft Active Directory**（**AD**）、**轻量级目录访问协议**（**LDAP**）的许多变种，或者另一个**身份管理系统**（**IMS**）时，都存在一个潜在的数据库等待测试。

凭证数据库黑客可能有不同的目标。最直接的目标是寻找合法用户的帐户，以允许黑客冒充用户并访问敏感信息。其他人将寻找可能尚未被禁用或隐藏的默认帐户，然后可以毫无顾忌地使用这些帐户进行特权访问、管理功能，甚至创建新的影子帐户，这些帐户可以用作后门，并保护最初被损害的帐户以供以后尝试。与 SQL 和 XPath 一样，LDAP 查询有自己的语法；与其他注入类型一样，未能对数据进行消毒的易受攻击的查询可能受到转义字符的影响，这些字符可以强制登录或快速提升权限。幸运的是，LDAP 在使用上更加具体，因此它比其他类型的注入更容易进行手动测试。另一方面，没有广泛使用的工具专门用于 LDAP 注入扫描或利用。Burp Suite 可以提供一些检测和一般的注入帮助，但更多信息请参考 OWASP 关于 LDAP 注入的指导：[`www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)`](https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006))。

## 超越说服 - 注入以执行

* * *

好吧，我们不再玩得很好了。也许攻击者已经决定一个网站对他们没有价值，但他们仍然想要否认其功能对合法用户的使用。也许他们正在寻找这个应用程序，并希望将其关闭并使应用程序所有者无助。或者更糟糕的是，也许他们只是使用这个网站来到达另一个网站，通过损害应用程序，他们希望影响或横向移动到另一个网站。无论动机是什么，一类注入攻击超越了说服应用程序吐露其秘密；它们反而试图说服服务器运行新代码或执行应用程序开发人员根本没有意图使用或允许的命令。

我们需要在坏人之前找到这些攻击。数据泄漏无疑是一个巨大的问题，但服务器的完全崩溃或长期受到威胁会威胁应用程序的存在以及依赖它的公司。

### 代码注入

代码注入用于实施所谓的缓冲区溢出攻击。这些攻击不是通过弹出消息来展示漏洞的存在，而是专注于利用应用程序安全验证中的这些漏洞来执行允许攻击者接管目标或使用受损服务器作为进入环境的枢纽的任意代码。简而言之，如果一个网站在 PHP 或 ASP 上运行，并通过 URL 查询传递信息，您可以通过简单地识别特征字符串来寻找代码注入漏洞，从而显示页面重定向被接受，从而找到漏洞所在。

```
/bWAPP/phpi.php?message=test
```

虽然这是一个相当温和的测试路径（我们不打算造成伤害），但我们可以通过改变消息并捕获结果来利用这个漏洞为我们的客户。如果可以通过一个简单的消息来改变 Web 服务器的行为，黑客将尝试使用标准的 PHP 函数在服务器上运行真正恶意的东西，以试图颠覆或接管 Web 服务器本身。

我修改了消息以展示谁掌控着，使用以下字符串，结果显示在以下截图中：

```
http://172.16.30.129/bWAPP/phpi.php?message=MikeRules
```

![](img/B03918_07_20.png)

成功的代码注入

### 溢出的乐趣

有几种代码注入形式会导致缓冲区溢出，每一种都专注于攻击底层 Web 或应用程序层服务器中的不同服务，或者是应用程序本身。开发人员通常不会注意到这些知名的溢出攻击，因为他们在管理大量库的复用，可能并不了解存在漏洞。尽管存在这些潜在问题，我们对这些问题了解更多，因此我们必须鼓励客户在修补和配置管理方面保持高度警惕。然而，他们自己的自定义代码和所选择的编程语言缺乏这种程度的审查，因此如果没有我们帮助测试他们的应用程序，他们将容易受到相同类型的攻击，但通过独特的向量。

我们将在 Web 渗透测试领域讨论的常见类别包括堆栈、堆、格式字符串、Unicode 和整数类型。

+   **堆栈溢出**是比较常见的一种被利用的形式，当使用松散类型的语言如 C++或 ASP.NET 时，开发人员未能在他们的代码中实施至少输入验证和/或堆栈完整性检查（也称为 canary 值）。由于没有对用户输入的类型或大小进行验证，攻击者利用这一点将更长的字符串注入到堆栈中，执行堆栈然后覆盖相邻的内存空间，从而允许恶意代码找到家园；被调用的函数现在指向恶意代码的内存空间顶部。

### 注意

一些 CPU 能够帮助防御这些溢出，因为它们是更现代的操作系统。确保 Web 应用程序团队在软件开发生命周期规范和设计阶段中指定硬件要求并考虑它们是非常值得的。

+   **堆溢出**与堆栈溢出类似，只是它们专注于通常不受硬件平台 CPU 保护的空间。堆是在程序调用时动态分配的，攻击者利用这一点通过使用这些宽松的规则来强制溢出，覆盖指针，从而允许黑客重定向 CPU，指向他们自己的恶意代码。鉴于它们在 2000 年代早期就被微软和 Linux 解决了，这些情况相当罕见，但鉴于它们的潜在影响，它们是非常值得检查的。

+   **格式字符串溢出**利用了代码中使用的系统调用和函数的不当设计。C 和 C++以可以传递多种类型的多个变量而不进行验证而臭名昭著。这些相同的函数属性可能包含对底层函数的控制指令，因此通常会看到格式字符串注入利用先前未使用的那些调用的部分来强制产生意外行为。

+   **Unicode 溢出**利用了编程语言标准字母表中不存在的字符来触发潜在的溢出。虽然不像堆和栈类型那样常见，但可以使用类似的预防措施来防止它们。

+   **整数溢出**仅仅是利用了对操作中整数输入的不良验证，使得它们加载了两个变量，这些变量包含了他们知道会导致答案超出分配空间的数字，从而创建了溢出。与 Unicode 一样，对前三种溢出类型的保护应该可以防止整数溢出。

对各种形式的缓冲区溢出进行测试可以包括在工具如 Burp Suite、w3af（[`w3af.org`](http://w3af.org)）和其他功能齐全的 DAST 套件的扫描中，但 Metasploit 可以帮助制作各种自定义脚本来利用它们。在**Primal Security**（[`www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/`](http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/)）上有一个很棒的教程，正如您所看到的，要使合适的缓冲区溢出攻击发生，需要做很多工作。

### Commix - 不那么有趣的命令注入

另一方面，命令注入并不是为了注入代码，反射回主机，并改变应用程序的行为。命令注入通过应用程序正常操作中使用的可注入命令找到一个窗口，从而使我们能够看到或接触到后端 Web 或应用程序层服务器。其目标是将额外的命令注入到变量字符串中，以在主机操作系统上运行本地命令，例如`copy`命令，重新配置接口，或者最坏的情况，如`fdisk`。这不是你典型的喜闹行为 - 这是残酷的事情。在 OWASP OTG（[`www.owasp.org/index.php/Command_Injection`](https://www.owasp.org/index.php/Command_Injection)）中有一个很好的讨论，而工具**Commix**（**Comm**and **I**njection E**x**ploiter）已经包含在 Kali Linux 中，以确保我们得到了覆盖。

要使用 Commix，您需要 URL（我们在这里使用 DVWA），与您会话相关的 cookie（我再次使用了拦截开启的 Burp），以及您要模糊处理的字段（在本例中是 IP），然后就可以开始了；我很快就获得了 shell 访问权限（如下面的截图所示）！

![](img/B03918_07_21.png)

通过 Commix 获得 shell 访问权限的代码注入

## HTTP 完蛋了？

* * *

到目前为止，本章讨论的所有攻击都涉及将字符串放置在我们知道可能对后端数据库造成严重破坏的表单字段中。许多网络服务现在根据用户输入和会话状态创建动态标头，并出现了一种新的攻击类型，以利用这可能打开的漏洞。当攻击者下定决心时，他们可以将信息注入到实际上在许多情况下类似于 XSS 的标头中。

例如，HTTP 在其语法上非常严格，它将回车和换行视为字段之间的特殊分隔点。如果 Web 服务器没有适当地拒绝或对这些输入进行消毒，攻击者可能会在其中插入一些内容，以注入他们自己的任意字段并传递他们的有效负载。这种攻击形式称为**HTTP 响应拆分**。

这类攻击的另一种形式涉及**HTTP 会话固定**，这是攻击者感知网站对用户进行身份验证并使用会话 ID 的一种方式，但未验证发送会话 ID 的人是谁，因此将任何人，包括攻击者和受害者客户端，都视为合法参与者（Web 服务器无法区分两者）。通过社会工程学，攻击者可以趁机强迫受害者点击一个链接，其中会话 ID 已经被攻击者选择。受害者然后进行身份验证，基本上告诉 Web 服务器这个会话 ID 是有效的。攻击者基本上种下了自己的 cookie，并让受害者为其背书。

### 注意

**HTTP 动词篡改**是另一个问题，它利用 HTTP 请求中输入验证的缺乏，并使用动词（POST、HEAD、GET、TRACE、TRACK、PUT、DELETE 等，[`www.restapitutorial.com/lessons/httpmethods.html`](http://www.restapitutorial.com/lessons/httpmethods.html)中有很好的介绍）。

这些攻击方法非常新颖和即将到来；除了 Burp 和 Wapati 等套件之外，Kali 中没有专门用于覆盖 HTTP 注入攻击的专用工具。有关更多信息，请访问**Watchfire**制作的白皮书（[`www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf`](http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf)）。

## 摘要

* * *

注入攻击种类繁多且致命。鉴于攻击者必须利用这些漏洞的种类、方法和目标的数量之多，动态内容能够得到保护是非常美妙的。这类攻击只能通过警惕和基于最佳实践的分割、净化和持续的渗透测试来预防。

在本章中，我们研究了各种注入攻击类别，其中 SQL 注入很可能是主角。鉴于现代应用框架中广泛使用 SQL，可以理解为什么更多的工具和关注被给予这种注入形式。然而，我们将看到这种情况能持续多久，因为随着处理能力的爆炸和对简化访问和可移植性的需求增加，XML 和 XPath 的使用也在增加。此外，不应忽略更专门的注入技术，因为 LDAP、命令和代码注入缺陷，虽然遇到频率较低，但对于服务器保护不足的公司来说可能是潜在的噩梦。总之，注入攻击可能是耗时和乏味的测试，但对手只需要找到一处漏洞就有可能得手。

在下一章中，我们将更加专注于技术攻击向量——加密缺陷和漏洞。正是在公众意识到这种依赖并坚持隐私和保密的时候，网络正以令人难以置信的速度增长。黑客在许多方面都领先于他们，等待着可以允许他们拦截、修改或暴露数据流内容并背叛网络应用程序和客户之间必须相互信任以正常运行的信任机制。如果你准备好接受一些可怕的东西，那就跟我进入第八章，*通过密码学测试来利用信任*！
