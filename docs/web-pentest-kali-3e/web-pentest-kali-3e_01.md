# 渗透测试和 Web 应用程序简介

Web 应用程序使用 HTTP 协议进行客户端和服务器之间的通信，并需要 Web 浏览器作为客户端界面。它可能是现代公司中最普遍的应用程序类型，从人力资源的组织气候调查到公司网站的 IT 技术服务。甚至厚客户端应用程序、移动应用程序和许多**物联网**（**IoT**）设备也通过 Web 服务和嵌入到其中的 Web 界面使用 Web 组件。

不久前，人们认为安全只在组织的边界和网络层面上是必要的，因此公司在物理和网络安全上花费了大量资金。然而，由于他们对组织内外的 Web 技术的依赖，这也带来了一种有些虚假的安全感。近年来，我们看到了关于数百万条记录的惊人数据泄露和违规事件的新闻，其中包括信用卡号码、健康历史、家庭地址以及来自世界各地的人们的社会安全号码（**SSN**）。其中许多攻击都是通过利用 Web 漏洞或设计失误开始的。

现代组织承认他们依赖于 Web 应用程序和 Web 技术，并且它们与网络和操作系统一样容易受到攻击，甚至更容易。这导致提供防护或防御 Web 攻击服务的公司数量增加，以及**Web 应用程序防火墙**（**WAF**）、**运行时应用程序自我保护**（**RASP**）、Web 漏洞扫描器和源代码扫描器等技术的出现或增长。此外，越来越多的组织发现在向最终用户发布应用程序之前测试其安全性非常有价值，这为有才华的黑客和安全专业人员提供了机会，他们可以利用自己的技能发现漏洞并提供修复建议，从而帮助公司、医院、学校和政府拥有更安全的应用程序和日益改进的软件开发实践。

# 主动安全测试

**渗透测试**和**道德黑客**是通过执行类似于任何一天可能发生的真实攻击的攻击方式来主动测试 Web 应用程序的方法。它们以受控的方式执行，目的是尽可能发现多个安全漏洞，并提供有关如何减轻这些漏洞带来的风险的反馈。

在向最终用户发布应用程序之前，对应用程序进行安全测试对公司非常有益。事实上，有一些安全意识很强的公司几乎已经将渗透测试、漏洞评估和源代码审查完全整合到了软件开发周期中。因此，当他们发布新的应用程序时，它已经经历了各个测试和修复阶段。

# 不同的测试方法论

人们经常对以下术语感到困惑，他们互换使用，但并不理解这些术语的某些方面虽然有重叠，但也存在细微的差异，需要您注意：

+   道德黑客

+   渗透测试

+   漏洞评估

+   安全审计

# 道德黑客

很少有人意识到黑客是一个被误解的术语；它对不同的人有不同的含义，而且往往黑客被认为是一个坐在黑暗的地方没有社交生活且有恶意意图的人。因此，在术语“黑客”前面加上了“道德”一词。术语“道德黑客”用来指称那些致力于发现系统漏洞和脆弱性、向系统的供应商或所有者报告，并有时帮助他们修复系统的专业人士。道德黑客使用的工具和技术与黑客或黑帽黑客使用的工具和技术类似，但目的不同，因为它以更专业的方式使用。道德黑客也被称为“安全研究员”。

# 渗透测试

渗透测试是本书中我们经常使用的一个术语，它是道德黑客的一个子集。它是一个更专业的术语，用来描述道德黑客的工作内容。如果你计划从事道德黑客或安全测试的职业，那么你经常会看到职位为渗透测试员的招聘信息。尽管渗透测试是道德黑客的一个子集，但它在很多方面有所不同。它是一种更简化的方式，用于识别系统中的漏洞，并确定漏洞是否可利用。渗透测试受到测试人员和被测试系统的所有者之间的合同的约束。为了确定要测试的系统，您需要定义测试的范围。需要定义“参与规则”，确定测试的方式。

# 漏洞评估

有时，组织可能只想识别其系统中存在的漏洞，而不实际利用它们并获取访问权限。漏洞评估比渗透测试更广泛。漏洞评估的最终结果是一个报告，按照发现的漏洞进行优先排序，最严重的漏洞排在前面，风险较低的漏洞排在报告的较低位置。这份报告对于知道自己存在安全问题并需要确定和优先处理最关键问题的客户非常有帮助。

# 安全审计

审计是一种系统性的程序，用于根据预先确定的一组标准来衡量系统的状态。这些标准可以是行业最佳实践或内部清单。审计的主要目标是衡量和报告符合情况。如果你正在审计一个 Web 服务器，一些最初需要注意的事项包括服务器上的开放端口、启用的有害 HTTP 方法（如 TRACE）、使用的加密标准和密钥长度。

# 进行渗透测试时需要考虑的因素

在计划执行渗透测试项目时，无论是作为专业渗透测试员为客户工作，还是作为公司内部安全团队的一部分，都需要在开始参与之前考虑一些方面。

# 参与规则

参与规则（RoE）是一份文件，涉及渗透测试的进行方式。在开始渗透测试之前，应明确规定 RoE 中的一些指令，例如：

+   测试的类型和范围

+   客户联系方式

+   客户 IT 团队通知

+   敏感数据处理

+   状态会议和报告

# 测试的类型和范围

测试的类型可以是黑盒测试、白盒测试或中间的灰盒测试，这取决于参与方式和与测试团队共享的信息量。

在每种类型的测试中，都有可以做和不可以做的事情。在**黑盒测试**中，测试团队从组织外部的攻击者的视角出发，渗透测试人员从零开始，试图识别网络地图、实施的防御机制、面向互联网的网站和服务等。尽管这种方法在模拟外部攻击者方面可能更加真实，但需要考虑到这些信息可能很容易从公共来源获取，或者攻击者可能是一个已经拥有这些信息的不满意的员工或前员工。因此，如果目标是仅供员工使用的内部应用程序，采用黑盒方法可能是浪费时间和金钱。

**白盒测试**是指测试团队获得有关目标的所有可用信息，有时甚至包括应用程序的源代码，以便在侦察和扫描上花费很少或没有时间。然后，灰盒测试是指向测试团队提供部分信息，例如应用程序的 URL、用户级文档和/或用户帐户。

**灰盒测试**在测试 Web 应用程序时特别有用，因为主要目标是在应用程序本身中发现漏洞，而不是在托管服务器或网络中。渗透测试人员可以使用用户帐户来采用恶意用户或通过社交工程获得访问权限的攻击者的视角。

在确定测试范围时，客户与测试团队需要评估哪些信息是有价值且需要保护的，并基于此确定需要测试哪些应用程序/网络以及对信息的访问程度。

# 客户联系方式

我们可以认同，即使在进行测试时采取了所有必要的预防措施，有时测试也可能出错，因为它涉及让计算机执行恶意操作。在客户端拥有正确的联系信息确实非常有帮助。渗透测试经常会变成**拒绝服务**（**DoS**）攻击。客户端的技术团队应该全天候可用，以防计算机崩溃，需要硬重启才能恢复在线状态。

渗透测试 Web 应用程序的优势在于可以在专门为此目的构建的环境中进行，从而使测试人员降低对客户生产资产的负面影响的风险。

# 客户 IT 团队通知

渗透测试还用作检查支持人员对事件和入侵尝试的响应准备情况的手段。您应该与客户讨论此事，无论是宣布还是未宣布的测试。如果是宣布的测试，请确保通知客户测试（攻击）将在何时何地进行，并提供测试的源 IP 地址，以避免其 IT 安全团队错过任何真正的入侵尝试。如果是未宣布的测试，请与客户讨论如果测试被自动系统或网络管理员阻止会发生什么。测试是否在那里结束，还是继续进行？这完全取决于测试的目的，是为了测试基础设施的安全性还是检查网络安全和事件处理团队的响应。即使进行未宣布的测试，也要确保升级矩阵中的某人知道测试的时间和日期。Web 应用程序渗透测试通常是宣布的。

# 敏感数据处理

在测试准备和执行过程中，测试团队将获得并可能发现有关公司、系统和/或其用户的敏感信息。敏感数据处理在 RoE 中需要特别注意，并且应采取适当的存储和通信措施（例如，对测试人员计算机进行全盘加密，如果通过电子邮件发送报告，则对报告进行加密等）。如果您的客户受到各种监管法律的覆盖，例如《健康保险可携带性和责任法》（HIPAA）、《格拉姆-利奇-布莱利法》（GLBA）或欧洲数据隐私法，只有授权人员才能查看个人用户数据。

# 状态会议和报告

沟通是成功的渗透测试的关键。测试团队和客户组织之间应定期安排会议，并由测试团队发布例行状态报告。测试团队应介绍他们已经达到的进展以及到目前为止发现的漏洞。客户组织还应确认他们的检测系统是否触发了由渗透尝试引起的任何警报。如果正在测试 Web 服务器并且部署了 WAF，则应记录和阻止攻击尝试。作为最佳实践，测试团队还应记录测试进行的时间。这将帮助安全团队将日志与渗透测试相关联。

WAF 通过分析客户端和服务器之间的 HTTP/HTTPS 流量工作，并且能够检测和阻止对 Web 应用程序的最常见攻击。

# 渗透测试的限制

尽管渗透测试被推荐并应定期进行，但渗透测试存在一定的限制。测试的质量和结果将直接取决于测试团队的技能。由于范围的限制、渗透测试人员对测试环境的访问限制以及测试人员使用的工具的限制，渗透测试无法找到所有的漏洞。以下是渗透测试的一些限制：

+   技能限制：如前所述，测试的成功和质量将直接取决于渗透测试团队的技能和经验。渗透测试可以分为三个广泛的类别：网络、系统和 Web 应用程序渗透测试。如果让一个擅长网络渗透测试的人参与测试 Web 应用程序的项目，将无法获得正确的结果。由于当今互联网上部署了大量的技术，很难找到一个精通这三个领域的人。一个测试人员可能对 Apache Web 服务器有深入的了解，但可能是第一次遇到 IIS 服务器。过去的经验也在测试的成功中起着重要作用；将一个低风险漏洞映射到具有高威胁级别的系统是一种只能通过经验获得的技能。

+   时间限制：渗透测试通常是一个短期项目，必须在预定的时间段内完成。测试团队需要在该期限内产生结果并确定漏洞。另一方面，攻击者有更多的时间来进行攻击，并可以仔细计划。渗透测试人员还必须在测试结束时提交报告，描述方法论、确定的漏洞和执行摘要。必须定期拍摄屏幕截图，然后将其添加到报告中。显然，攻击者不会编写任何报告，因此可以将更多时间用于实际攻击。

+   自定义利用的限制：在某些高度安全的环境中，常规的渗透测试框架和工具几乎没有用处，团队需要跳出常规思维，例如创建自定义利用和手动编写脚本以达到目标。创建利用非常耗时，它会影响测试的总预算和时间。无论如何，编写自定义利用应该是任何自重的渗透测试人员的技能组合的一部分。

+   避免 DoS 攻击：黑客和渗透测试是一种让计算机或应用程序执行其设计之外功能的艺术。因此，有时候测试可能导致 DoS 攻击，而不是获取系统访问权限。许多测试人员为了避免意外造成系统停机而不进行此类测试。由于系统未经过 DoS 攻击测试，它们更容易受到脚本小子的攻击，这些脚本小子只是在寻找此类可通过互联网访问的系统，以便通过将其下线来获得声誉。脚本小子是指那些利用计算机系统中易于发现和众所周知的弱点来获取声誉，而不理解或关心潜在的有害后果的技术水平低下的个人。应该向客户介绍 DoS 测试的利弊，以帮助他们做出正确的决策。

+   访问限制：网络被划分为不同的段，测试团队通常只能访问和测试那些具有服务器并可从互联网访问的段，以模拟真实世界的攻击。然而，这样的测试无法检测到客户所在的内部网络上的配置问题和漏洞。

+   使用工具的限制：有时，渗透测试团队只被允许使用客户批准的工具和利用框架清单。无论是免费版本还是商业版本，没有一种工具是完整的。测试团队需要了解这些工具，并在它们缺少功能时寻找替代品。

为了克服这些限制，大型组织设有专门的渗透测试团队，负责研究新的漏洞并定期进行测试。其他组织除了进行渗透测试外，还进行定期的配置审查。

# 测试 Web 应用程序的需求

随着互联网面向的网站数量的增加以及进行在线业务的组织数量的增加，Web 应用程序和 Web 服务器成为攻击者的有吸引力的目标。Web 应用程序无处不在，遍布公共和私有网络，因此攻击者不需要担心目标的缺乏。只需要一个 Web 浏览器就可以与 Web 应用程序进行交互。一些 Web 应用程序的缺陷，如逻辑错误，甚至可以被一个外行人利用。例如，由于逻辑实现不当，如果一家公司拥有一个电子商务网站，在结账过程之后允许用户将商品添加到购物车，那么一个恶意用户通过试错发现这一点后，就可以轻松地利用这个漏洞，而无需任何特殊工具。

Web 应用程序的漏洞也为恶意软件和病毒的传播提供了手段，这些恶意软件和病毒可以在几分钟内传播到全球。黑客通过利用 Web 应用程序和安装恶意软件获得可观的经济利益，然后将其传播给应用程序的用户。

边缘防火墙对流向 Web 服务器的入站 HTTP 流量更加宽松，因此攻击者不需要打开任何特殊端口。HTTP 协议是多年前设计的，没有提供任何内置的安全功能；它是一个明文协议，需要使用 HTTPS 协议进行额外的层次保护通信。它也没有提供个别会话标识，而是由开发人员自行设计。许多开发人员直接从大学毕业后被雇佣，他们只具备编程语言的理论知识，没有 Web 应用程序编程的安全方面的实际经验。即使漏洞被报告给开发人员，他们也需要很长时间来修复，因为他们忙于 Web 应用程序的功能创建和增强部分。

安全编码从 Web 应用程序的架构和设计阶段开始，因此需要早期集成到开发周期中。后期集成安全将证明困难，并且需要大量的重做工作。在开发阶段早期使用威胁建模来识别风险和威胁，对于减少生产就绪的 Web 应用程序代码中的漏洞非常有帮助。

投入资源编写安全代码是减少 Web 应用程序漏洞的有效方法。然而，编写安全代码很容易说，但很难实施。

# 防范对 Web 应用的攻击的原因

防范对 Web 应用的攻击的一些最有说服力的原因如下：

+   保护客户数据

+   遵守法律法规

+   声誉损失

+   收入损失

+   保护免受业务中断的影响。

如果 Web 应用程序与信用卡信息进行交互和存储，则需要符合**支付卡行业**（**PCI**）制定的规则和法规。PCI 有具体的指南，例如审查 Web 应用程序中的所有代码以查找漏洞，或安装 WAF 以减轻风险。

当 Web 应用程序未经漏洞测试，攻击者获得访问客户数据的权限时，如果客户对公司提起诉讼，这可能严重影响公司的品牌。这也可能导致收入损失，因为许多客户将转移到可能提供更好安全性的竞争对手那里。

对 Web 应用的攻击也可能导致严重的服务中断，如果是 DoS 攻击，服务器可能会被关闭以清理暴露的数据，或进行取证调查。这可能会在财务报表中产生负面影响。

这些原因足以说服您组织的高级管理层投入资源（包括资金、人力和技能）来提高 Web 应用程序的安全性。

# Kali Linux

在本书中，我们将使用 Kali Linux 提供的工具来完成我们的测试。Kali Linux 是一个基于 Debian 的 GNU/Linux 发行版。Kali Linux 被安全专业人员用于执行攻击性安全任务，并由一家名为 Offensive Security 的公司维护。Kali Linux 的前身是 BackTrack，它是渗透测试人员使用的主要工具之一，使用了超过六年，直到 2013 年被 Kali Linux 取代。2015 年 8 月，Kali Linux 的第二个版本以代号 Kali Sana 发布，2016 年 1 月，它转换为“滚动发布”。

这意味着软件会持续更新，而无需更改操作系统版本。Kali Linux 附带了一套大量的流行黑客工具，这些工具已经安装了所有的先决条件，可以直接使用。我们将深入研究这些工具，并使用它们来测试那些存在于现实世界 Web 应用程序中的重大缺陷的 Web 应用程序。

# 渗透测试人员的 Web 应用程序概述

Web 应用程序涉及的远不止 HTML 代码和 Web 服务器。如果您不是积极参与 Web 应用程序开发的程序员，那么您可能对 HTTP 协议的内部工作原理、Web 应用程序与数据库的交互方式以及用户单击链接或在 Web 浏览器中输入网站 URL 时发生的情况一无所知。

作为渗透测试人员，了解信息如何从客户端流向服务器和数据库，然后再返回客户端非常重要。本节将包括一些信息，帮助没有 Web 应用程序渗透测试先验知识的个人利用 Kali Linux 提供的工具进行端到端的 Web 渗透测试。您将对以下内容有一个广泛的概述：

+   HTTP 协议

+   HTTP 中的头部

+   使用 cookie 进行会话跟踪

+   HTML

+   Web 应用程序的架构

# HTTP 协议

在 Web 服务器和客户端之间传输 Web 应用程序流量的底层协议称为**超文本传输协议**（**HTTP**）。协议的最常见实现是 HTTP/1.1，定义在 RFC 7230-7237 中，取代了在 RFC 2616 中定义的旧版本。最新版本称为 HTTP/2，于 2015 年 5 月发布，并在 RFC 7540 中定义。第一个版本 HTTP/1.0 现在被认为已过时，不推荐使用。

随着互联网的发展，HTTP 协议的后续版本添加了新功能。在 HTTP/1.1 中，添加了持久连接、`OPTIONS`方法以及 HTTP 支持缓存的几项改进功能。

RFC 是由**互联网工程任务组**（**IETF**）创建的详细技术文档，描述了互联网标准和协议。RFC 文档的最终版本成为实现协议时可以遵循的标准。

HTTP 是一种客户端-服务器协议，其中客户端（Web 浏览器）向服务器发出请求，服务器则响应请求。服务器的响应主要以 HTML 格式的页面形式呈现。默认情况下，HTTP 协议使用端口`80`，但可以配置 Web 服务器和客户端以使用不同的端口。

HTTP 是一种明文协议，这意味着客户端和服务器之间的所有信息都是未加密的，任何中间人都可以看到并理解它。为了解决 HTTP 设计中的这个缺陷，发布了一种新的实现，它通过**安全套接字层**（**SSL**）协议建立了一个加密的通信通道，然后通过该通道发送 HTTP 数据包。这被称为 HTTPS 或 HTTP over SSL。近年来，SSL 越来越多地被一种名为**传输层安全**（**TLS**）的新协议取代，目前版本为 1.2。

# 了解 HTTP 请求和响应

HTTP 请求是客户端向服务器发送的消息，以获取一些信息或执行某些操作。它由一个空行分隔的两个部分组成：头部和正文。头部包含与请求本身、预期的响应、cookie 和其他相关控制信息相关的所有信息，正文包含交换的数据。HTTP 响应具有相同的结构，只是内容和所包含信息的使用有所不同。

# 请求头

以下是在浏览`www.bing.com`时使用 Web 应用程序代理捕获的 HTTP 请求：

![](img/00005.jpeg)

此标头中的第一行指示请求的方法：`GET`，请求的资源：`/`（即根目录）和协议版本：`HTTP 1.1`。HTTP 标头中还可以有其他几个字段。我们将讨论最相关的字段：

+   **主机**：这指定了被请求资源的主机和端口号。一个 web 服务器可能包含多个站点，或者可能包含共享托管或负载均衡等技术。该参数用于区分由同一基础设施提供的不同站点/应用程序。

+   **用户代理**：该字段用于服务器识别将接收信息的客户端类型（即 Web 浏览器）。对于开发人员来说，它很有用，因为响应可以根据用户的配置进行适应，因为并非所有 HTTP 协议和 Web 开发语言中的所有功能都与所有浏览器兼容。

+   **Cookie**：Cookie 是客户端和服务器之间交换的临时值，用于保持会话信息等其他原因。

+   **内容类型**：这指示服务器请求体中包含的媒体类型。

+   **授权**：HTTP 允许通过此参数进行每个请求的客户端身份验证。有多种身份验证模式，最常见的是`Basic`、`Digest`、`NTLM`和`Bearer`。

# 响应标头

在接收到请求并处理其内容后，服务器可能会以如下所示的消息作出响应：

![](img/00006.jpeg)

响应标头的第一行包含状态码（`200`），这是一个三位数的代码。这有助于浏览器理解操作的状态。以下是一些重要字段的详细信息：

+   **状态码**：没有名为状态码的字段，但该值通过标头传递。`2xx`系列状态码用于向 Web 浏览器传达成功的操作。`3xx`系列用于指示重定向，当服务器希望客户端连接到另一个 URL 时，当网页被移动时。`4xx`系列用于指示客户端请求中的错误，并要求用户在重新发送之前修改请求。`5xx`系列表示服务器端错误，因为服务器无法完成操作。在前面的标头中，状态码为`200`，表示操作成功。完整的 HTTP 状态码列表可以在[`developer.mozilla.org/en-US/docs/Web/HTTP/Status`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)找到。

+   **设置 Cookie**：如果定义了此字段，将在客户端中建立一个 Cookie 值，服务器可以使用该值来识别客户端并存储临时数据。

+   **缓存控制**：这指示是否将响应的内容（图像、脚本代码或 HTML）存储在浏览器缓存中以减少页面加载时间，以及如何进行存储。

+   **服务器**：该字段指示服务器类型和版本。由于这些信息可能对潜在攻击者有兴趣，因此最好将服务器配置为省略其响应，就像前面截图中显示的标头一样。

+   **内容长度**：该字段将包含一个值，指示响应体中的字节数。它用于使另一方知道当前请求/响应何时完成。

可以在以下 URL 找到所有标头字段及其用法的详尽列表：[`www.w3.org/Protocols/rfc2616/rfc2616-sec14.html`](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)。

# HTTP 方法

当客户端向服务器发送请求时，还应通知服务器对所需资源执行何种操作。例如，如果用户只想查看网页的内容，它将调用`GET`方法，该方法通知服务器将网页的内容发送给客户端的 Web 浏览器。

本节描述了几种方法。对于渗透测试人员来说，它们很有趣，因为它们指示两个端点之间正在发生的数据交换类型。

# GET 方法

GET 方法用于检索由 URL 标识或由其标识的过程生成的任何信息。GET 请求可以从客户端获取参数，然后通过 URL 本身将这些参数的名称和值附加到 Web 应用程序中。如下所示的标头中，当您在 Bing 搜索引擎中发送“网络渗透测试”的搜索查询时，它是通过 URL 发送的：

！[](img/00007.jpeg)

# POST 方法

POST 方法与 GET 方法类似。它用于从服务器检索数据，但是它通过请求的正文传递内容。由于数据现在通过请求的正文传递，攻击者更难检测和攻击底层操作。如下所示的 POST 请求中，用户名（login）和密码（pwd）不是通过 URL 发送的，而是通过与标头之间的空行分隔的正文发送的：

！[](img/00008.jpeg)

# HEAD 方法

HEAD 方法与 GET 方法相同，只是服务器在响应中不包含消息体；也就是说，HEAD 请求的响应只是 GET 请求的响应头。

# TRACE 方法

当使用 TRACE 方法时，接收服务器会将 TRACE 响应与响应体中的原始请求消息一起返回。TRACE 方法用于识别中间设备（如代理服务器和防火墙）对请求所做的任何更改。某些代理服务器在数据包通过时会编辑 HTTP 标头，可以使用 TRACE 方法来识别这一点。它用于测试目的，因为它可以让您跟踪对方接收到了什么。

# PUT 和 DELETE 方法

PUT 和 DELETE 方法是 WebDAV 的一部分，它是 HTTP 协议的扩展，允许在 Web 服务器上管理文档和文件。开发人员使用它将生产就绪的网页上传到 Web 服务器上。PUT 用于将数据上传到服务器，而 DELETE 用于删除数据。在现代应用程序中，PUT 和 DELETE 也用于 Web 服务以执行数据库上的特定操作。PUT 用于插入或修改记录，而 DELETE 用于删除、禁用或防止将来读取某些信息。

# OPTIONS 方法

OPTIONS 方法用于查询服务器以获取请求的 URL 可用的通信选项。在下面的标头中，我们可以看到对 OPTIONS 请求的响应：

！[](img/00009.jpeg)

了解 HTTP 数据包的布局非常重要，因为它包含有用的信息，并且用户可以控制其中的几个字段，从而给攻击者注入恶意数据或操纵应用程序的某些行为提供了机会。

# 在 HTTP 中保持会话

HTTP 是一种无状态的客户端-服务器协议，客户端发出请求，服务器以数据作为响应。下一个请求被视为完全独立的新请求，与之前的请求无关。HTTP 请求的设计使得它们彼此独立。当您在网上购物时将商品添加到购物车中时，应用程序需要一种机制将商品与您的账户关联起来。每个应用程序可能使用不同的方式来标识每个会话。

追踪会话最常用的技术是通过服务器设置的会话 ID（标识符）。一旦用户使用有效的用户名和密码进行身份验证，就会为该用户分配一个唯一的随机会话 ID。在客户端发送的每个请求中，都会包含唯一的会话 ID，以将请求与经过身份验证的用户关联起来。会话 ID 可以使用`GET`或`POST`方法共享。使用`GET`方法时，会话 ID 将成为 URL 的一部分；使用`POST`方法时，ID 将在 HTTP 消息的正文中共享。服务器维护一个将用户名映射到分配的会话 ID 的表。分配会话 ID 的最大优势是，即使 HTTP 是无状态的，用户也不需要在每个请求中进行身份验证；浏览器会提供会话 ID，服务器会接受它。

会话 ID 也有一个缺点：任何获得会话 ID 的人都可以冒充用户，而无需用户名和密码。此外，会话 ID 的强度取决于用于生成它的随机程度，这可能有助于防止暴力破解攻击。

# Cookie

在 HTTP 通信中，**Cookie**是由服务器存储在客户端文件系统或 Web 浏览器内存中的具有名称、值和一些行为参数的单个信息。Cookie 是客户端和 Web 服务器之间传递会话 ID 的事实上的标准机制。使用 Cookie 时，服务器通过在 HTTP 响应头中设置`Set-Cookie`字段为客户端分配一个唯一的 ID。当客户端接收到头部时，它将存储 Cookie 的值，即会话 ID，存储在本地文件或浏览器的内存中，并将其与发送它的网站 URL 关联起来。当用户重新访问原始网站时，浏览器将发送 Cookie 值，以识别用户。

除了会话跟踪，Cookie 还可以用于存储终端客户端的偏好信息，例如语言和其他配置选项，这些信息将在会话之间持久存在。

# 服务器和客户端之间的 Cookie 流程

Cookie 始终由服务器设置和控制。Web 浏览器只负责在每个请求中将其发送到服务器。在下图中，您可以看到向服务器发出了一个`GET`请求，并且服务器上的 Web 应用程序选择设置一些 Cookie 来识别用户和用户在先前请求中选择的语言。在客户端发出的后续请求中，Cookie 成为请求的一部分：

![](img/00010.jpeg)

# 持久性和非持久性 Cookie

Cookie 被分为两个主要类别。持久性 Cookie 以文本文件的形式存储在客户端设备的内部存储中。由于 Cookie 存储在硬盘上，它可以在浏览器崩溃或不同会话之间持久存在。不同的浏览器会以不同的方式存储持久性 Cookie。例如，Internet Explorer 将 Cookie 保存在用户文件夹内的文本文件中，路径为`AppData\Roaming\Microsoft\Windows\Cookie`，而 Google Chrome 使用一个 SQLite3 数据库，也存储在用户文件夹内，路径为`AppData\Local\Google\Chrome\User Data\Default\cookies`。正如前面提到的，Cookie 可以用于传递会话 ID、偏好设置和购物数据等敏感信息。如果存储在硬盘上，它无法防止恶意用户对其进行修改。

为了解决持久性 Cookie 面临的安全问题，程序员提出了另一种更常用的 Cookie 类型，称为**非持久性 Cookie**，它存储在 Web 浏览器的内存中，在硬盘上不留痕迹，并通过请求和响应头在 Web 浏览器和服务器之间传递。非持久性 Cookie 仅在服务器指定的预定义时间内有效。

# Cookie 参数

除了 cookie 的名称和值之外，Web 服务器还设置了其他几个参数，用于定义 cookie 的范围和可用性，如下所示的响应头：

![](img/00011.jpeg)

以下是一些参数的详细信息：

+   **域**：指定将发送 cookie 的域。

+   **路径**：为了进一步锁定 cookie，可以指定`路径`参数。如果指定的域是`email.com`，路径设置为`/mail`，那么 cookie 只会发送到`email.com/mail`内的页面。

+   **HttpOnly**：这是一个参数，用于减轻**跨站脚本攻击**（**XSS**）带来的风险，因为 JavaScript 无法访问 cookie。

+   **安全**：如果设置了此参数，cookie 只能通过安全通信渠道发送，即 SSL 和 TLS。

+   **过期时间**：cookie 将存储到此参数指定的时间。

# HTTP 响应中的 HTML 数据

响应体中的数据是对最终用户有用的信息。它通常包含 HTML 格式的数据，但也可以是**JavaScript 对象表示法**（**JSON**）或**可扩展标记语言**（**XML**）数据、脚本代码或二进制文件，如图像和视频。最初在 Web 上存储的只有纯文本信息，以一种更适合阅读的方式进行格式化，同时能够包含表格、图像和链接到其他文档的内容。这被称为**超文本标记语言**（**HTML**），Web 浏览器是用来解释它的工具。HTML 文本使用标签进行格式化。

HTML 不是一种编程语言。

# 服务器端代码

脚本代码和 HTML 格式化由 Web 浏览器解释和呈现。这被称为**客户端代码**。涉及到通过服务器检索客户端请求的信息、会话跟踪以及大部分应用程序逻辑的过程是通过**服务器端代码**在服务器上执行的，使用的语言有 PHP、ASP.NET、Java、Python、Ruby 和 JSP 等。该代码生成一个输出，然后可以使用 HTML 进行格式化。当您看到以`.php`扩展名结尾的 URL 时，表示该页面可能包含 PHP 代码。然后必须通过服务器的 PHP 引擎运行，以便在加载 Web 页面时生成动态内容。

# 多层 Web 应用程序

随着今天使用的 Web 应用程序变得越来越复杂，将 Web 应用程序部署在单个系统上的传统方式已经成为过去的故事。将所有的鸡蛋放在一个篮子里并不是部署关键业务应用程序的明智方式，因为它严重影响应用程序的性能、安全性和可用性。单个服务器托管应用程序和数据的简单设计仅适用于流量不大的小型 Web 应用程序。设计 Web 应用程序的三层方法是未来的发展方向。

# 三层 Web 应用程序设计

在三层 Web 应用程序中，表示层、应用程序层和数据层之间存在物理分离，具体描述如下：

+   **表示层**：这是接收客户端连接并将响应发送回客户端的服务器。它是应用程序的前端。**表示层**对于 Web 应用程序至关重要，因为它是用户与应用程序的其余部分之间的接口。在表示层接收到的数据会传递给应用程序层的组件进行处理。接收到的输出使用 HTML 格式化，并显示在用户的 Web 客户端上。Apache 和 nginx 是开源软件程序，而 Microsoft IIS 是商业软件，部署在表示层。

+   **应用层**：处理密集型处理和主要应用程序逻辑在**应用层**中完成。一旦演示层从客户端收集所需数据并将其传递给应用层，工作在该层的组件可以对数据应用业务逻辑。然后将输出返回到演示层，以发送回客户端。如果客户端请求数据，则从数据层提取数据，将其处理成对客户端有用的形式，并传递给演示层。Java、Python、PHP 和 ASP.NET 是在应用层工作的编程语言。

+   **数据访问层**：实际存储和数据存储库工作在**数据访问层**。当客户端需要数据或发送数据进行存储时，它会被应用层传递到数据访问层进行持久存储。在该层工作的组件负责维护数据并保持其完整性和可用性。它们还负责管理应用层的并发连接。MySQL 和 Microsoft SQL 是两种最常用的在该层工作的技术。**结构化查询语言**（**SQL**）关系数据库是当今 Web 应用程序中最常用的，尽管 NoSQL 数据库（如 MongoDB、CouchDB 和其他 NoSQL 数据库）也被广泛使用，特别是在大数据分析应用程序中，它们以与关系数据库传统的行列表格格式不同的形式存储信息。SQL 是一种数据定义和查询语言，许多数据库产品都支持它作为检索和更新数据的标准。

下图显示了演示层、应用层和数据访问层如何协同工作：

![](img/00012.jpeg)

# Web 服务

Web 服务可以被视为不包含演示层的 Web 应用程序。面向服务的架构允许 Web 服务提供者与该服务的消费者轻松集成。Web 服务使不同的应用程序可以共享数据和功能。它们允许消费者在不知道数据的格式或位置的情况下通过互联网访问数据。

当您不想公开数据模型或用于访问数据的逻辑，但仍希望数据对其消费者随时可用时，这变得非常关键。一个例子是由股票交易所提供的 Web 服务。在线经纪人可以使用此 Web 服务获取有关股票的实时信息，并在其自己的网站上显示，具有自己的演示风格和品牌，以供最终用户购买。经纪人的网站只需要调用服务并请求公司的数据。当服务回复数据时，Web 应用程序可以解析信息并显示它。

Web 服务是平台无关的。股票交易应用程序可以用任何语言编写，而服务仍然可以被调用，而不管用于构建应用程序的底层技术是什么。服务提供者和消费者需要达成一致的只有数据交换的规则。

目前有两种不同的开发 Web 服务的方式：

+   **简单对象访问协议**（**SOAP**）

+   **表述性状态转移**（**REST**），也称为 RESTful Web 服务。

# 介绍 SOAP 和 REST Web 服务

SOAP 一直是开发 Web 服务的传统方法，但它有许多缺点，现在应用程序正在转向 REST 或 RESTful Web 服务。在使用 SOAP Web 服务时，XML 是唯一可用的数据交换格式，而 REST Web 服务可以使用 JSON 和其他数据格式。尽管基于 SOAP 的 Web 服务在某些情况下仍然被推荐使用，因为它具有额外的安全规范，但由于其简单性，轻量级的 REST Web 服务是许多 Web 服务开发人员首选的方法。SOAP 是一种协议，而 REST 是一种架构风格。亚马逊、Facebook、谷歌和雅虎已经转向 REST Web 服务。

REST Web 服务的一些特点如下：

+   它们与 CRUD 操作非常配合

+   它们具有更好的性能和可扩展性

+   它们可以处理多种输入和输出格式

+   对于连接到 Web 服务的开发人员来说，学习曲线较小

+   REST 设计理念与 Web 应用程序类似

CRUD 代表创建、读取、更新和删除；它描述了持久存储的四个基本功能。

SOAP 相对于 REST 的主要优势在于 SOAP 是独立于传输的，而 REST 仅在 HTTP 上工作。REST 基于 HTTP，因此影响标准 Web 应用程序的相同漏洞也可以用于攻击它。幸运的是，相同的安全最佳实践可以应用于保护 REST Web 服务。

在开发 SOAP 服务时，将 XML 数据包装在 SOAP 请求中，然后使用 HTTP 发送的复杂性迫使许多组织转向 REST 服务。它还需要一个 Web 服务定义语言（WSDL）文件，该文件提供与服务相关的信息。必须维护一个 UDDI 目录，其中发布了 WSDL 文件。

REST 服务的基本思想是，与使用 SOAP 等复杂机制不同，它直接通过 HTTP 与服务提供者进行通信，无需任何额外的协议。它使用 HTTP 来创建、读取、更新和删除数据。

SOAP 基于 Web 服务的消费者发送的请求如下所示：

```
<?xml version="1.0"?> 
<soap:Envelope 
 soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
  <soap:body sp="http://www.stockexchange.com/stockprice"> 
    <sp:GetStockPrice> 
      <sp:Stockname>xyz</sp:Stockname> 
    </sp:GetStockPrice> 
  </soap:Body> 
</soap:Envelope> 
```

另一方面，发送到 REST Web 服务的请求可能如下所示：

```
http://www.stockexchange.com/stockprice/Stockname/xyz 
```

应用程序使用`GET`请求从 Web 服务中读取数据，这种方法开销较低，与冗长复杂的 SOAP 请求不同，开发人员编码起来更容易。虽然 REST Web 服务也可以使用 XML 返回数据，但很少使用的 JSON 是首选的返回数据的方法。

# Web 服务中的 HTTP 方法

REST Web 服务可能会以与标准 Web 应用程序不同的方式处理 HTTP 方法。这种行为取决于开发人员的偏好，但将`POST`、`GET`、`PUT`和`DELETE`方法与 CRUD 操作相关联的做法越来越流行。最常见的方法如下：

+   创建：`POST`

+   读取：`GET`

+   更新：`PUT`

+   删除：`DELETE`

一些 API 实现交换了`PUT`和`POST`的功能。

# XML 和 JSON

Web 服务使用 XML 和 JSON 来表示结构化的数据集或对象。

如前面的章节所讨论的，XML 使用基于标签、属性和标签的值的语法；例如，应用程序的文件菜单可以表示如下：

```
<menu id="m_file" value="File"> 
  <popup> 
    <item value="New" onclick="CreateDocument()" /> 
    <item value="Open" onclick="OpenDocument()" /> 
    <item value="Close" onclick="CloseDocument()" /> 
  </popup> 
</menu> 
```

相反，JSON 使用一种更经济的语法，类似于 C 和 Java 编程语言。JSON 格式的相同菜单如下所示：

```
{"menu": { 
  "id": "m_file", 
  "value": "File", 
  "popup": { 
    "item": [ 
      {"value": "New", "onclick": "NewDocument()"}, 
      {"value": "Open", "onclick": "OpenDocument()"}, 
      {"value": "Close", "onclick": "CloseDocument()"} 
    ] 
  } 
}} 
```

# AJAX

**异步 JavaScript 和 XML**（AJAX）是多个现有 Web 技术的组合，它允许客户端在没有用户直接干预的情况下发送请求和处理响应。它还可以减轻服务器对应用程序逻辑处理任务的负担。AJAX 允许您与 Web 服务器进行通信，而无需用户在 Web 浏览器中明确发出新请求。这导致服务器的响应更快，因为 Web 页面的部分可以单独更新，从而改善用户体验。AJAX 利用 JavaScript 连接并从服务器检索信息，而无需重新加载整个 Web 页面。

以下是使用 AJAX 的一些好处：

+   **提高速度**：使用 AJAX 的目标是提高 Web 应用程序的性能。通过更新单个表单元素，服务器上只需要进行最少的处理，从而提高性能。客户端的响应速度也得到了显著提高。

+   **用户友好**：在基于 AJAX 的应用程序中，用户无需重新加载整个页面以刷新网站的特定部分。这使应用程序更具交互性和用户友好性。它还可以用于实时验证和自动完成。

+   **异步调用**：基于 AJAX 的应用程序设计为对 Web 服务器进行异步调用，因此称为异步 JavaScript 和 XML。这使用户可以在幕后更新部分网页时与网页进行交互。

+   **减少网络利用率**：通过不进行完整页面刷新，减少网络利用率。在加载大型图像、视频或动态内容（如 Java 小程序或 Adobe Flash 程序）的 Web 应用程序中，使用 AJAX 可以优化网络利用率。

# AJAX 的构建块

如前所述，AJAX 是使用常见 Web 技术构建 Web 应用程序的混合体。使用这些 Web 技术设计应用程序会产生基于 AJAX 的应用程序。以下是 AJAX 的组成部分：

+   **JavaScript**：基于 AJAX 的应用程序最重要的组成部分是客户端的 JavaScript 代码。JavaScript 在后台与 Web 服务器进行交互，并在显示给用户之前处理信息。它使用**XMLHttpRequest**（XHR）API 在服务器和客户端之间传输数据。XHR 存在于后台，用户对其存在毫无察觉。

+   **动态 HTML（DHTML）**：一旦从服务器检索到数据并由 JavaScript 处理，Web 页面的元素需要更新以反映来自服务器的响应。一个完美的例子是在填写在线表单时输入用户名。表单会动态更新，以反映并告知用户用户名是否已在网站上注册。使用 DHTML 和 JavaScript，您可以实时更新页面内容。DHTML 在 AJAX 出现之前就已存在。仅使用 DHTML 的主要缺点是它严重依赖于客户端代码来更新页面。大多数情况下，您没有在客户端加载所有内容，需要与服务器端代码进行交互。这就是 AJAX 通过创建客户端代码和服务器端代码之间的连接来发挥作用的地方，通过 XHR 对象实现。在 AJAX 之前，您必须使用 JavaScript 小程序。

+   文档对象模型（DOM）：DOM 是一种用于组织 HTML 或 XML 文档中的元素的框架。它是一种表示和与 HTML 对象交互的约定。从逻辑上讲，可以将 HTML 文档解析为一棵树，其中每个元素被视为树节点，树的每个节点都有自己的属性和事件。例如，HTML 文档的 body 对象将具有一组特定的属性，如`text`、`link`、`bgcolor`等。每个对象还具有事件。这个模型允许 JavaScript 通过 DHTML 访问和动态更新页面内容。DHTML 是一个浏览器功能，DOM 充当实现它的接口。

# AJAX 工作流程

下图说明了基于 AJAX 的应用程序各个组件之间的交互。与传统的 Web 应用程序相比，AJAX 引擎是主要的新增内容。AJAX 引擎的额外层作为所有通过 AJAX 进行的请求和响应的中间人。AJAX 引擎是 JavaScript 解释器：

！[](img/00013.jpeg)

以下是用户与基于 AJAX 的应用程序交互的工作流程。用户界面和 AJAX 引擎是客户端 Web 浏览器上的组件：

1.  用户在浏览器中输入网页的 URL，浏览器向服务器发送一个 HTTP 请求。服务器处理请求并返回 HTML 内容，浏览器通过 Web 渲染引擎显示该内容。在 HTML 中，网页嵌入在 JavaScript 代码中，当遇到事件时由 JavaScript 解释器执行。

1.  当与网页交互时，用户遇到一个使用嵌入的 JavaScript 代码并触发事件的元素。一个例子是谷歌搜索页面。当用户开始输入搜索查询时，底层的 AJAX 引擎拦截用户的请求。AJAX 引擎通过 HTTP 请求将请求转发给服务器。这个请求对用户来说是透明的，用户不需要显式地点击提交按钮或刷新整个页面。

1.  在服务器端，应用程序层处理请求并将数据以 JSON、HTML 或 XML 形式返回给 AJAX 引擎。AJAX 引擎将此数据转发给 Web 渲染引擎，以便由浏览器显示。Web 浏览器使用 DHTML 仅更新 Web 页面的选定部分，以反映新数据。

当你遇到一个基于 AJAX 的应用程序时，请记住以下额外的要点：

+   XMLHttpRequest API 在幕后完成了这个魔术。由于其名称过长，它通常被称为 XHR。首先实例化一个名为`xmlhttp`的 JavaScript 对象，并用它来发送和捕获来自服务器的响应。要使 AJAX 工作，需要浏览器支持 XHR。所有最新版本的主流 Web 浏览器都支持此 API。

+   AJAX 的 XML 部分有点误导人。应用程序可以使用除 XML 之外的任何格式，例如 JSON、纯文本、HTTP，甚至是在 AJAX 引擎和 Web 服务器之间交换数据时使用的图像。JSON 是首选的格式，因为它是轻量级的，并且可以转换为 JavaScript 对象，进一步允许脚本轻松访问和操作数据。

+   多个异步请求可以同时进行，而不需要等待一个请求完成。

+   许多开发人员使用简化应用程序设计任务的 AJAX 框架。JQuery、Dojo Toolkit、Google Web Toolkit（GWT）和 Microsoft AJAX 库（.NET 应用程序）是众所周知的框架。

一个 AJAX 请求的示例如下：

```
function loadfile() 
{ 
  //initiating the XMLHttpRequest object 
  var xmlhttp; 
  xmlhttp = new XMLHttpRequest();   
  xmlhttp.onreadystatechange=function() 
  { 
    if (xmlHttp.readyState==4) 
    { 
      showContents(xmlhttp.ResponseText); 
    } 
  //GET method to get the links.txt file   
  xmlHttp.open("GET", "links.txt", true); 
```

函数`loadfile()`首先实例化`xmlhttp`对象。然后使用该对象从服务器获取一个文本文件。当服务器返回文本文件时，它显示文件的内容。文件及其内容是在没有用户参与的情况下加载的，如上面的代码片段所示。

# HTML5

HTML 规范的第五个版本于 2014 年 10 月首次发布。这个新版本指定了用于媒体播放、拖放、Web 存储、可编辑内容、地理位置、本地 SQL 数据库、加密、Web 套接字等的 API，这些 API 可能从安全测试的角度来看很有趣，因为它们为攻击打开了新的路径或试图解决以前 HTML 版本中的一些安全问题。

# WebSockets

正如之前所述，HTTP 是一种无状态协议。这意味着每个请求都会建立一个新的连接，并在每个响应后关闭。HTML5 的 WebSocket 是一种通信接口，允许客户端和服务器之间建立永久的双向连接。

客户端通过以下`GET`请求打开 WebSocket 连接：

```
GET /chat HTTP/1.1 
Host: server.example.com 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== 
Sec-WebSocket-Protocol: chat, superchat 
Sec-WebSocket-Version: 13 
Origin: http://example.com 
```

如果服务器理解请求并接受连接，其响应将如下所示：

```
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= 
Sec-WebSocket-Protocol: chat 
```

然后，HTTP 连接被 WebSocket 连接取代，并且它变成了一个双向的二进制协议，不一定与 HTTP 兼容。

# 概述

本章作为对 Web 应用程序的道德黑客和渗透测试的介绍。我们首先确定了测试 Web 应用程序的不同方法。我们还讨论了在开始测试之前需要定义的重要规则。接下来，我们研究了在今天的世界中测试 Web 应用程序的重要性以及不进行定期测试的风险。然后，我们简要介绍了 Kali Linux 作为测试平台，并快速回顾了现代 Web 应用程序中使用的概念和技术。
